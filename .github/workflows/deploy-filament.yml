name: Deploy Filament Backend (Docker Image) - V2

on:
  push:
    branches: [main]
    paths:
      - "filament/**"
      - "docker-compose.yml"
      - "nginx/**"
      - ".github/workflows/deploy-filament.yml"
  workflow_dispatch:
    inputs:
      enabled:
        description: 'Force enable this workflow (set to "true" to run)'
        required: false
        default: 'false'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: declared-as-ala/sobitas-backend-v2

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    # For workflow_dispatch, only run if enabled=true
    # For push events, paths filter in on: section already handles filtering
    if: |
      github.event_name == 'push' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.enabled == 'true')
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify Dockerfile exists
        run: |
          set -e
          test -f filament/Dockerfile || (echo "âŒ filament/Dockerfile not found" && exit 1)
          echo "âœ“ filament/Dockerfile found"

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v6
        with:
          context: ./filament
          file: ./filament/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Deploy to VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_PASSWORD }}
          script_stop: true
          command_timeout: 300s
          script: |
            set -e
            echo "========================================"
            echo "ðŸš€ Filament Backend V2 Deploy Started"
            echo "========================================"

            APP_DIR="/root/sobitas-project"
            cd "$APP_DIR" || { echo "âŒ $APP_DIR not found"; exit 1; }

            # â”€â”€ Step 1: Pull docker-compose.yml only (no full git pull) â”€â”€
            # We only need docker-compose.yml changes, not the full repo
            echo "ðŸ“¥ Pulling docker-compose.yml..."
            git fetch origin main || true
            git checkout origin/main -- docker-compose.yml 2>/dev/null || echo "âš  docker-compose.yml unchanged"

            # â”€â”€ Step 2: Login to GHCR â”€â”€
            echo "ðŸ” Logging in to GHCR..."
            if [ -n "${{ secrets.GHCR_PAT }}" ]; then
              echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            else
              echo "âš  GHCR_PAT not set, using public pull"
            fi

            # â”€â”€ Step 3: Pull latest backend image â”€â”€
            echo "ðŸ“¦ Pulling latest backend image..."
            docker pull ghcr.io/declared-as-ala/sobitas-backend-v2:latest || {
              echo "âŒ Failed to pull image"
              exit 1
            }

            # â”€â”€ Step 4: Ensure dependencies are healthy â”€â”€
            echo "ðŸ” Ensuring MySQL + Redis are healthy..."
            docker compose up -d mysql redis
            echo "â³ Waiting for MySQL to be healthy..."
            timeout=60
            while [ $timeout -gt 0 ]; do
              if docker compose exec -T mysql mysqladmin ping -h localhost --silent 2>/dev/null; then
                echo "âœ“ MySQL is healthy"
                break
              fi
              sleep 2
              timeout=$((timeout - 2))
            done
            if [ $timeout -le 0 ]; then
              echo "âŒ MySQL health check timeout"
              exit 1
            fi

            # â”€â”€ Step 5: Recreate backend-v2 container with new image â”€â”€
            echo "ðŸ”„ Recreating backend-v2 container..."
            docker compose up -d --force-recreate --no-deps backend-v2 || {
              echo "âŒ Failed to recreate backend-v2"
              exit 1
            }

            # â”€â”€ Step 6: Wait for backend-v2 to be ready â”€â”€
            echo "â³ Waiting for backend-v2 to start..."
            sleep 10

            # â”€â”€ Step 7: Copy public assets and create storage symlink â”€â”€
            echo "ðŸ“‹ Copying public assets and creating storage symlink..."
            docker compose run --rm backend-v2-public-init || {
              echo "âŒ Failed to initialize public volume"
              exit 1
            }

            # â”€â”€ Step 8: Restart nginx to pick up new assets â”€â”€
            echo "ðŸ”„ Restarting nginx-v2..."
            docker compose up -d --no-deps backend-nginx-v2 || {
              echo "âŒ Failed to restart nginx"
              exit 1
            }

            # â”€â”€ Step 9: Clear Laravel caches (before OPcache reset) â”€â”€
            echo "ðŸ§¹ Clearing Laravel caches..."
            docker compose exec -T backend-v2 php artisan config:clear || true
            docker compose exec -T backend-v2 php artisan cache:clear || true
            docker compose exec -T backend-v2 php artisan view:clear || true
            docker compose exec -T backend-v2 php artisan route:clear || true
            echo "âœ“ Laravel caches cleared"

            # â”€â”€ Step 10: CRITICAL - Reset OPcache (validate_timestamps=0) â”€â”€
            echo "ðŸ”„ Resetting OPcache (validate_timestamps=0)..."
            # Use opcache_reset() via PHP (container was just recreated, so this ensures clean state)
            docker compose exec -T backend-v2 php -r "if (function_exists('opcache_reset')) { opcache_reset(); echo 'OPcache reset successful'; } else { echo 'OPcache not available'; }" || true
            echo "âœ“ OPcache reset complete"

            # â”€â”€ Step 11: Rebuild Laravel caches (after OPcache reset) â”€â”€
            echo "ðŸ”¨ Rebuilding Laravel caches..."
            docker compose exec -T backend-v2 php artisan config:cache || true
            docker compose exec -T backend-v2 php artisan route:cache || true
            docker compose exec -T backend-v2 php artisan view:cache || true
            echo "âœ“ Laravel caches rebuilt"

            # â”€â”€ Step 12: Health check â”€â”€
            echo "========================================"
            echo "ðŸ¥ Health Check"
            echo "========================================"
            docker compose ps mysql redis backend-v2 backend-nginx-v2
            echo ""
            
            # Test backend endpoint (non-fatal)
            echo "ðŸ” Testing backend endpoint..."
            sleep 3
            set +e
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8083/admin/login 2>/dev/null)
            CURL_EXIT=$?
            set -e
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "302" ]; then
              echo "âœ“ Backend is responding (HTTP $HTTP_CODE)"
            else
              echo "âš  Backend health check returned HTTP $HTTP_CODE (curl exit $CURL_EXIT, may still be starting)"
            fi

            echo ""
            echo "=== Recent Logs ==="
            docker compose logs --tail 30 backend-v2

            # â”€â”€ Step 13: Cleanup old images â”€â”€
            echo "ðŸ§¹ Cleaning up old images..."
            docker image prune -f || true

            echo "========================================"
            echo "âœ… Filament Backend V2 Deploy Completed"
            echo "========================================"
